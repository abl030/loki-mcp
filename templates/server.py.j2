"""Loki MCP Server (auto-generated).

Generated for Loki {{ loki_version }}.
Total tools: ~{{ tool_count }}

DO NOT EDIT THIS FILE. All changes must be made in the generator or templates.
"""

from __future__ import annotations

import json
import os
import re
import time
from datetime import datetime, timezone
from typing import Any

import httpx
from fastmcp import FastMCP

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

LOKI_URL = os.environ.get("LOKI_URL", "http://localhost:3100")
LOKI_USERNAME = os.environ.get("LOKI_USERNAME", "")
LOKI_PASSWORD = os.environ.get("LOKI_PASSWORD", "")
LOKI_TOKEN = os.environ.get("LOKI_TOKEN", "")
LOKI_ORG_ID = os.environ.get("LOKI_ORG_ID", "")
LOKI_VERIFY_SSL = os.environ.get("LOKI_VERIFY_SSL", "false").lower() == "true"
LOKI_MODULES = os.environ.get("LOKI_MODULES", "")
LOKI_READ_ONLY = os.environ.get("LOKI_READ_ONLY", "false").lower() == "true"
LOKI_TIMEOUT = int(os.environ.get("LOKI_TIMEOUT", "30"))

# Parse enabled modules
_enabled_modules: set[str] | None = None
if LOKI_MODULES:
    _enabled_modules = {m.strip() for m in LOKI_MODULES.split(",") if m.strip()}

ALL_MODULES = {{ modules.keys() | list | sort }}


def _module_enabled(module: str | None) -> bool:
    """Check if a module is enabled."""
    if module is None:
        return True
    if _enabled_modules is not None:
        return module in _enabled_modules
    return True


# ---------------------------------------------------------------------------
# Timestamp helper
# ---------------------------------------------------------------------------

_DURATION_RE = re.compile(r"^(\d+)([smhdw])$")
_DURATION_UNITS = {"s": 1, "m": 60, "h": 3600, "d": 86400, "w": 604800}


def _parse_timestamp(value: str) -> str:
    """Convert a human-friendly timestamp to RFC3339 or pass through.

    Accepts:
      - RFC3339 strings (passed through)
      - Unix epoch seconds (converted to RFC3339)
      - Duration strings like '1h', '30m', '2d' (converted to RFC3339 relative to now)
    """
    if not value:
        return ""

    # Duration like "1h", "30m"
    match = _DURATION_RE.match(value.strip())
    if match:
        amount = int(match.group(1))
        unit = match.group(2)
        seconds_ago = amount * _DURATION_UNITS[unit]
        ts = datetime.now(timezone.utc).timestamp() - seconds_ago
        return datetime.fromtimestamp(ts, tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    # Unix epoch (integer or float)
    try:
        epoch = float(value)
        if epoch > 1e12:  # nanoseconds
            epoch = epoch / 1e9
        elif epoch > 1e9:  # milliseconds
            epoch = epoch / 1e3
        return datetime.fromtimestamp(epoch, tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    except ValueError:
        pass

    # Assume RFC3339 or other valid format — pass through
    return value


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------


class LokiClient:
    """Async HTTP client for Loki API with auth support."""

    def __init__(self) -> None:
        auth = None
        if LOKI_USERNAME and LOKI_PASSWORD:
            auth = httpx.BasicAuth(LOKI_USERNAME, LOKI_PASSWORD)

        self._client = httpx.AsyncClient(
            base_url=LOKI_URL,
            auth=auth,
            verify=LOKI_VERIFY_SSL,
            timeout=float(LOKI_TIMEOUT),
        )

    def _headers(self) -> dict[str, str]:
        headers: dict[str, str] = {}
        if LOKI_TOKEN:
            headers["Authorization"] = f"Bearer {LOKI_TOKEN}"
        if LOKI_ORG_ID:
            headers["X-Scope-OrgID"] = LOKI_ORG_ID
        return headers

    async def request(
        self,
        method: str,
        path: str,
        params: dict | None = None,
        json_data: Any = None,
        data: Any = None,
        content: str | bytes | None = None,
        content_type: str | None = None,
    ) -> httpx.Response:
        """Make an HTTP request to Loki."""
        headers = self._headers()
        if content_type:
            headers["Content-Type"] = content_type

        resp = await self._client.request(
            method,
            path,
            params=params,
            json=json_data,
            data=data,
            content=content,
            headers=headers,
        )
        return resp

    async def close(self) -> None:
        await self._client.aclose()


# Singleton client
_client = LokiClient()


async def _get_client() -> LokiClient:
    return _client


# ---------------------------------------------------------------------------
# Response formatting
# ---------------------------------------------------------------------------


def _format_response(data: Any, summary: str | None = None) -> str:
    """Format API response data for tool output."""
    if isinstance(data, str):
        if summary:
            return f"{summary}\n\n{data}"
        return data
    if summary:
        return f"{summary}\n\n{json.dumps(data, indent=2, default=str)}"
    return json.dumps(data, indent=2, default=str)


def _unwrap_loki_response(resp: httpx.Response) -> Any:
    """Unwrap Loki's standard response envelope.

    Loki wraps most JSON responses in {"status": "success", "data": ...}.
    This extracts the data field when present.
    """
    if resp.status_code == 204:
        return {"status": "success", "message": "No content (204)"}

    content_type = resp.headers.get("content-type", "")

    # Text responses (ready, metrics, config, services)
    if "text/" in content_type or "text/html" in content_type:
        return resp.text

    # Try JSON
    try:
        body = resp.json()
    except Exception:
        return resp.text

    # Unwrap envelope
    if isinstance(body, dict) and "status" in body:
        if body["status"] != "success":
            msg = body.get("message", body.get("error", "Unknown error"))
            raise RuntimeError(f"Loki API error: {msg}")
        if "data" in body:
            return body["data"]
    return body


# ---------------------------------------------------------------------------
# MCP Server
# ---------------------------------------------------------------------------

mcp = FastMCP(
    "Loki",
    instructions=(
        "This server provides {{ tool_count }} tools for interacting with Grafana Loki. "
        "Call loki_search_tools first to find the right tool by keyword before browsing "
        "the full tool list. Call loki_get_overview for system status. "
        "If a tool returns an unexpected error, call loki_report_issue to report it."
    ),
)


# ===========================================================================
# Direct API Tools (generated from endpoint inventory)
# ===========================================================================
{% for ep in endpoints %}
# --- {{ ep.tool_name }} ({{ ep.module }}) ---

@mcp.tool()
async def {{ ep.tool_name }}(
{% for p in ep.required_params %}
{% if p.name not in ['streams', 'rules_yaml'] %}
    {{ p.name }}: {{ p.type }},
{% elif p.name == 'streams' %}
    streams: list,
{% elif p.name == 'rules_yaml' %}
    rules_yaml: str,
{% endif %}
{% endfor %}
{% if ep.mutation %}
    confirm: bool = False,
{% endif %}
{% for p in ep.optional_params %}
    {{ p.name }}: {{ p.type }} = {{ p.default }},
{% endfor %}
) -> str:
    """{{ ep.description }}
{% if ep.parameters %}

    Args:
{% for p in ep.parameters %}
        {{ p.name }}: {{ p.description }}
{% endfor %}
{% if ep.mutation %}
        confirm: Must be True to execute. Returns preview if False.
{% endif %}
{% endif %}
{% if ep.notes %}

    Note: {{ ep.notes }}
{% endif %}
    """
{% if ep.mutation %}
    if not confirm:
        preview = {"action": "{{ ep.tool_name }}"}
{% for p in ep.required_params %}
{% if p.name == 'streams' %}
        preview["streams_count"] = len(streams)
{% else %}
        preview["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
{% for p in ep.optional_params %}
{% if p.type == 'str' %}
        if {{ p.name }}:
            preview["{{ p.name }}"] = {{ p.name }}
{% else %}
        preview["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
        return _format_response(
            preview,
{% if ep.danger %}
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
{% else %}
            "DRY RUN: Set confirm=True to execute.",
{% endif %}
        )

{% endif %}
    if not _module_enabled("{{ ep.module }}"):
        return _format_response({"error": "Module '{{ ep.module }}' is not enabled. Set LOKI_MODULES to include it."})
{% if ep.mutation %}

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})
{% endif %}

    client = await _get_client()
{% if ep.is_text_response %}
    resp = await client.request("{{ ep.method }}", "{{ ep.path }}")
    resp.raise_for_status()
    return _format_response(resp.text, "{{ ep.tool_name }} response")
{% elif ep.is_form_encoded %}
    resp = await client.request(
        "{{ ep.method }}",
        "{{ ep.path }}",
        data={"log_level": log_level},
        content_type="application/x-www-form-urlencoded",
    )
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)
    return _format_response(result, "Log level updated")
{% elif ep.is_yaml_body %}
    path = "{{ ep.path }}"
{% for p in ep.path_params %}
    path = path.replace("{{ '{' }}{{ p.name }}{{ '}' }}", {{ p.name }})
{% endfor %}
    resp = await client.request(
        "{{ ep.method }}",
        path,
        content=rules_yaml.encode(),
        content_type="application/yaml",
    )
    resp.raise_for_status()
    return _format_response({"status": "success", "message": "Rule group created/updated"})
{% elif ep.id == 'push' %}
    payload = {"streams": streams}
    resp = await client.request("{{ ep.method }}", "{{ ep.path }}", json_data=payload)
    resp.raise_for_status()
    return _format_response({"status": "success", "message": f"Pushed {len(streams)} stream(s)"})
{% elif ep.is_no_content %}
{% if ep.path_params %}
    path = "{{ ep.path }}"
{% for p in ep.path_params %}
    path = path.replace("{{ '{' }}{{ p.name }}{{ '}' }}", {{ p.name }})
{% endfor %}
{% endif %}
{% if ep.query_params %}
    params = {}
{% for p in ep.query_params %}
{% if p.required %}
    params["{{ p.name }}"] = {{ p.name }}
{% else %}
    if {{ p.name }}:
        params["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endfor %}
{% endif %}
    resp = await client.request(
        "{{ ep.method }}",
{% if ep.path_params %}
        path,
{% else %}
        "{{ ep.path }}",
{% endif %}
{% if ep.query_params %}
        params=params,
{% endif %}
    )
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)
    return _format_response(result, "{{ ep.tool_name }} completed")
{% else %}
{% if ep.path_params %}
    path = "{{ ep.path }}"
{% for p in ep.path_params %}
    path = path.replace("{{ '{' }}{{ p.name }}{{ '}' }}", {{ p.name }})
{% endfor %}
{% endif %}
    params = {}
{% for p in ep.query_params %}
{% if p.name == 'match' %}
    params["match[]"] = match
{% elif p.required %}
    params["{{ p.name }}"] = {% if p.type == 'int' %}str({{ p.name }}){% else %}{{ p.name }}{% endif %}

{% else %}
    if {{ p.name }}:
{% if p.name in ['start', 'end'] %}
        params["{{ p.name }}"] = _parse_timestamp({{ p.name }})
{% elif p.type == 'int' %}
        params["{{ p.name }}"] = str({{ p.name }})
{% else %}
        params["{{ p.name }}"] = {{ p.name }}
{% endif %}
{% endif %}
{% endfor %}
    resp = await client.request(
        "{{ ep.method }}",
{% if ep.path_params %}
        path,
{% else %}
        "{{ ep.path }}",
{% endif %}
        params=params,
    )
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)
{% if 'data.result' in ep.response_fields %}
    if isinstance(result, dict) and "result" in result:
        entries = result["result"]
        return _format_response(result, f"Found {len(entries)} result(s)")
{% endif %}
    return _format_response(result)
{% endif %}

{% endfor %}

# ===========================================================================
# High-Level AI-Friendly Tools
# ===========================================================================


@mcp.tool()
async def loki_search_logs(
    host: str = "",
    container: str = "",
    unit: str = "",
    pattern: str = "",
    severity: str = "",
    start: str = "1h",
    end: str = "",
    limit: int = 100,
    direction: str = "backward",
) -> str:
    """Search logs by host, container, unit, pattern, and severity — no LogQL needed.

    Builds a LogQL query internally from structured parameters.

    Args:
        host: Filter by host label (exact match).
        container: Filter by container label (exact match).
        unit: Filter by systemd unit label (exact match).
        pattern: Regex pattern to filter log lines (e.g. 'error|timeout').
        severity: Minimum severity: 'debug', 'info', 'warn', 'error', 'critical', 'fatal'.
        start: Start time — duration like '1h', '30m' or RFC3339. Default: 1h ago.
        end: End time — duration or RFC3339. Default: now.
        limit: Maximum log entries to return (default: 100).
        direction: 'backward' (newest first) or 'forward' (oldest first).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled."})

    # Build stream selector
    labels = {}
    if host:
        labels["host"] = host
    if container:
        labels["container"] = container
    if unit:
        labels["unit"] = unit

    if not labels:
        selector = '{}'
    else:
        parts = [f'{k}="{v}"' for k, v in labels.items()]
        selector = "{" + ", ".join(parts) + "}"

    # Build pipeline
    pipeline = ""
    if pattern:
        pipeline += f' |~ "{pattern}"'

    severity_levels = {"debug": 0, "info": 1, "warn": 2, "warning": 2, "error": 3, "critical": 4, "fatal": 5}
    if severity and severity.lower() in severity_levels:
        level_num = severity_levels[severity.lower()]
        level_patterns = [k for k, v in severity_levels.items() if v >= level_num and k != "warning"]
        if level_patterns:
            sev_regex = "|".join(level_patterns)
            pipeline += f' |~ "(?i)({sev_regex})"'

    query = selector + pipeline

    # Execute query
    client = await _get_client()
    params: dict[str, str] = {"query": query, "limit": str(limit), "direction": direction}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/query_range", params=params)
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)

    # Format output
    summary = f"Query: {query}"
    if isinstance(result, dict) and "result" in result:
        streams = result["result"]
        total_lines = sum(len(s.get("values", [])) for s in streams)
        summary += f"\nStreams: {len(streams)}, Log lines: {total_lines}"
    return _format_response(result, summary)


@mcp.tool()
async def loki_error_summary(
    host: str = "",
    start: str = "1h",
    end: str = "",
    limit: int = 50,
) -> str:
    """Aggregate errors across containers for a host.

    Searches for error/fail/exception/panic/fatal patterns and groups by container.

    Args:
        host: Filter by host label. Leave empty for all hosts.
        start: Start time (default: 1h ago).
        end: End time (default: now).
        limit: Maximum entries per stream (default: 50).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled."})

    selector = "{" + f'host="{host}"' + "}" if host else "{}"
    query = selector + ' |~ "(?i)(error|fail|exception|panic|fatal)"'

    client = await _get_client()
    params: dict[str, str] = {"query": query, "limit": str(limit), "direction": "backward"}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/query_range", params=params)
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)

    # Build summary
    summary_data: dict[str, dict] = {}
    if isinstance(result, dict) and "result" in result:
        for stream in result["result"]:
            labels = stream.get("stream", {})
            key = labels.get("container", labels.get("unit", labels.get("host", "unknown")))
            values = stream.get("values", [])
            if key not in summary_data:
                summary_data[key] = {"count": 0, "latest": "", "first_seen": ""}
            summary_data[key]["count"] += len(values)
            if values:
                summary_data[key]["latest"] = values[0][1][:200]
                summary_data[key]["first_seen"] = values[-1][0]

    return _format_response(
        {"query": query, "error_summary": summary_data},
        f"Error summary: {sum(s['count'] for s in summary_data.values())} errors across {len(summary_data)} source(s)",
    )


@mcp.tool()
async def loki_volume_by_label(
    label: str = "host",
    start: str = "1h",
    end: str = "",
    limit: int = 20,
) -> str:
    """Find the noisiest hosts/containers by log volume.

    Args:
        label: Label to aggregate by (default: 'host'). Common: 'host', 'container', 'unit'.
        start: Start time (default: 1h ago).
        end: End time (default: now).
        limit: Maximum results (default: 20).
    """
    if not _module_enabled("index"):
        return _format_response({"error": "Module 'index' is not enabled."})

    client = await _get_client()
    params: dict[str, str] = {"query": "{}", "limit": str(limit), "targetLabels": label}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/index/volume", params=params)
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)
    return _format_response(result, f"Volume by {label}")


@mcp.tool()
async def loki_compare_hosts(
    hosts: str,
    pattern: str = "",
    start: str = "1h",
    end: str = "",
    limit: int = 50,
) -> str:
    """Compare logs across multiple hosts side-by-side.

    Args:
        hosts: Comma-separated host names (e.g. 'doc1,igpu,wsl').
        pattern: Optional regex pattern to filter log lines.
        start: Start time (default: 1h ago).
        end: End time (default: now).
        limit: Maximum entries per host (default: 50).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled."})

    host_list = [h.strip() for h in hosts.split(",") if h.strip()]
    if not host_list:
        return _format_response({"error": "At least one host is required."})

    host_regex = "|".join(host_list)
    selector = '{host=~"' + host_regex + '"}'
    query = selector
    if pattern:
        query += f' |~ "{pattern}"'

    client = await _get_client()
    params: dict[str, str] = {"query": query, "limit": str(limit), "direction": "backward"}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/query_range", params=params)
    resp.raise_for_status()
    result = _unwrap_loki_response(resp)

    # Group by host
    by_host: dict[str, int] = {}
    if isinstance(result, dict) and "result" in result:
        for stream in result["result"]:
            h = stream.get("stream", {}).get("host", "unknown")
            by_host[h] = by_host.get(h, 0) + len(stream.get("values", []))

    return _format_response(
        {"query": query, "results": result, "lines_per_host": by_host},
        f"Comparing {len(host_list)} host(s): {', '.join(host_list)}",
    )


@mcp.tool()
async def loki_get_overview() -> str:
    """System summary: build info, readiness, services, label inventory.

    Calls multiple status endpoints to build a comprehensive overview.
    No parameters needed.
    """
    client = await _get_client()
    overview: dict[str, Any] = {}

    # Readiness
    try:
        resp = await client.request("GET", "/ready")
        overview["ready"] = resp.status_code == 200
        overview["ready_text"] = resp.text.strip()
    except Exception as e:
        overview["ready"] = False
        overview["ready_error"] = str(e)

    # Build info
    try:
        resp = await client.request("GET", "/loki/api/v1/status/buildinfo")
        if resp.status_code == 200:
            overview["buildinfo"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    # Labels
    try:
        resp = await client.request("GET", "/loki/api/v1/labels")
        if resp.status_code == 200:
            overview["labels"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    # Host values
    try:
        resp = await client.request("GET", "/loki/api/v1/label/host/values")
        if resp.status_code == 200:
            overview["hosts"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    # Container values
    try:
        resp = await client.request("GET", "/loki/api/v1/label/container/values")
        if resp.status_code == 200:
            overview["containers"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    return _format_response(overview, "Loki System Overview")


# --- Tool discovery ---

_ALL_TOOLS: dict[str, str] = {
{% for ep in endpoints %}
    "{{ ep.tool_name }}": "{{ ep.description[:100] | replace('"', '\\"') }}",
{% endfor %}
    "loki_search_logs": "Search logs by host/container/unit/pattern/severity without LogQL",
    "loki_error_summary": "Aggregate errors across containers for a host",
    "loki_volume_by_label": "Find noisiest hosts/containers by log volume",
    "loki_compare_hosts": "Compare logs across multiple hosts side-by-side",
    "loki_get_overview": "System summary: build info, readiness, labels, hosts",
    "loki_search_tools": "Search for tools by keyword",
    "loki_report_issue": "Generate a structured bug report",
    "loki_validate_query": "Validate and format a LogQL query",
}


@mcp.tool()
async def loki_search_tools(keyword: str) -> str:
    """Search for Loki tools by keyword.

    Args:
        keyword: Search term to match against tool names and descriptions.
    """
    keyword_lower = keyword.lower()
    matches = []
    for name, desc in _ALL_TOOLS.items():
        if keyword_lower in name.lower() or keyword_lower in desc.lower():
            matches.append({"tool": name, "description": desc})

    if not matches:
        return _format_response(
            {"keyword": keyword, "matches": []},
            f"No tools matching '{keyword}'. Try a broader search.",
        )
    return _format_response(
        {"keyword": keyword, "matches": matches},
        f"Found {len(matches)} tool(s) matching '{keyword}'",
    )


@mcp.tool()
async def loki_report_issue(
    tool_name: str,
    error: str,
    parameters: str = "",
    description: str = "",
) -> str:
    """Generate a structured bug report for a Loki MCP tool issue.

    Args:
        tool_name: Name of the tool that failed.
        error: Error message or unexpected behavior.
        parameters: Parameters used when the error occurred.
        description: Additional context about what you were trying to do.
    """
    report = {
        "tool": tool_name,
        "error": error,
        "parameters": parameters,
        "description": description,
        "loki_url": LOKI_URL,
        "gh_command": (
            f'gh issue create --repo abl030/loki-mcp '
            f'--title "Bug: {tool_name} — {error[:50]}" '
            f'--body "## Tool\\n`{tool_name}`\\n\\n'
            f'## Error\\n```\\n{error}\\n```\\n\\n'
            f'## Parameters\\n```\\n{parameters}\\n```\\n\\n'
            f'## Description\\n{description}"'
        ),
    }
    return _format_response(report, "Bug report generated. Run the gh command to file it.")


@mcp.tool()
async def loki_validate_query(query: str) -> str:
    """Validate and format a LogQL query. Returns the prettified form or an error.

    Args:
        query: LogQL query string to validate.
    """
    if not _module_enabled("format"):
        return _format_response({"error": "Module 'format' is not enabled."})

    client = await _get_client()
    resp = await client.request("GET", "/loki/api/v1/format_query", params={"query": query})

    if resp.status_code == 200:
        result = _unwrap_loki_response(resp)
        return _format_response(
            {"valid": True, "original": query, "formatted": result},
            "Query is valid",
        )
    else:
        try:
            body = resp.json()
            error_msg = body.get("message", body.get("error", resp.text))
        except Exception:
            error_msg = resp.text
        return _format_response(
            {"valid": False, "original": query, "error": error_msg},
            "Query is INVALID",
        )


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    mcp.run()
