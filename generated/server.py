"""Loki MCP Server (auto-generated).

Generated for Loki 3.x.
Total tools: ~42

DO NOT EDIT THIS FILE. All changes must be made in the generator or templates.
"""

from __future__ import annotations

import json
import os
import re
import time
from datetime import datetime, timezone
from typing import Any

import httpx
from fastmcp import FastMCP

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

LOKI_URL = os.environ.get("LOKI_URL", "http://localhost:3100")
LOKI_USERNAME = os.environ.get("LOKI_USERNAME", "")
LOKI_PASSWORD = os.environ.get("LOKI_PASSWORD", "")
LOKI_TOKEN = os.environ.get("LOKI_TOKEN", "")
LOKI_ORG_ID = os.environ.get("LOKI_ORG_ID", "")
LOKI_VERIFY_SSL = os.environ.get("LOKI_VERIFY_SSL", "false").lower() == "true"
LOKI_MODULES = os.environ.get("LOKI_MODULES", "")
LOKI_READ_ONLY = os.environ.get("LOKI_READ_ONLY", "false").lower() == "true"
LOKI_TIMEOUT = int(os.environ.get("LOKI_TIMEOUT", "30"))

# Parse enabled modules
_enabled_modules: set[str] | None = None
if LOKI_MODULES:
    _enabled_modules = {m.strip() for m in LOKI_MODULES.split(",") if m.strip()}

ALL_MODULES = ['admin', 'delete', 'format', 'index', 'ingest', 'patterns', 'query', 'rules', 'status']


def _module_enabled(module: str | None) -> bool:
    """Check if a module is enabled."""
    if module is None:
        return True
    if _enabled_modules is not None:
        return module in _enabled_modules
    return True


# ---------------------------------------------------------------------------
# Timestamp helper
# ---------------------------------------------------------------------------

_DURATION_RE = re.compile(r"^(\d+)([smhdw])$")
_DURATION_UNITS = {"s": 1, "m": 60, "h": 3600, "d": 86400, "w": 604800}


def _parse_timestamp(value: str) -> str:
    """Convert a human-friendly timestamp to RFC3339 or pass through.

    Accepts:
      - RFC3339 strings (passed through)
      - Unix epoch seconds (converted to RFC3339)
      - Duration strings like '1h', '30m', '2d' (converted to RFC3339 relative to now)
    """
    if not value:
        return ""

    # Duration like "1h", "30m"
    match = _DURATION_RE.match(value.strip())
    if match:
        amount = int(match.group(1))
        unit = match.group(2)
        seconds_ago = amount * _DURATION_UNITS[unit]
        ts = datetime.now(timezone.utc).timestamp() - seconds_ago
        return datetime.fromtimestamp(ts, tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    # Unix epoch (integer or float)
    try:
        epoch = float(value)
        if epoch > 1e12:  # nanoseconds
            epoch = epoch / 1e9
        elif epoch > 1e9:  # milliseconds
            epoch = epoch / 1e3
        return datetime.fromtimestamp(epoch, tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    except ValueError:
        pass

    # Assume RFC3339 or other valid format — pass through
    return value


def _format_ns_timestamp(ns_str: str) -> str:
    """Convert a nanosecond timestamp string to human-readable RFC3339.

    Converts '1770868733562049000' to '2026-02-12T11:58:53Z'.
    Returns original string on failure.
    """
    try:
        ns = int(ns_str)
        dt = datetime.fromtimestamp(ns / 1e9, tz=timezone.utc)
        return dt.strftime("%Y-%m-%dT%H:%M:%SZ")
    except (ValueError, TypeError, OSError):
        return str(ns_str)


def _format_log_values(result: Any) -> None:
    """Convert nanosecond timestamps in log stream results to RFC3339 in-place.

    Walks result["result"][*]["values"] and converts each entry[0] timestamp.
    """
    if not isinstance(result, dict) or "result" not in result:
        return
    for stream in result["result"]:
        values = stream.get("values", [])
        for entry in values:
            if len(entry) >= 1:
                entry[0] = _format_ns_timestamp(entry[0])


# ---------------------------------------------------------------------------
# HTTP Client
# ---------------------------------------------------------------------------


class LokiClient:
    """Async HTTP client for Loki API with auth support."""

    def __init__(self) -> None:
        auth = None
        if LOKI_USERNAME and LOKI_PASSWORD:
            auth = httpx.BasicAuth(LOKI_USERNAME, LOKI_PASSWORD)

        self._client = httpx.AsyncClient(
            base_url=LOKI_URL,
            auth=auth,
            verify=LOKI_VERIFY_SSL,
            timeout=float(LOKI_TIMEOUT),
        )

    def _headers(self) -> dict[str, str]:
        headers: dict[str, str] = {}
        if LOKI_TOKEN:
            headers["Authorization"] = f"Bearer {LOKI_TOKEN}"
        if LOKI_ORG_ID:
            headers["X-Scope-OrgID"] = LOKI_ORG_ID
        return headers

    async def request(
        self,
        method: str,
        path: str,
        params: dict | None = None,
        json_data: Any = None,
        data: Any = None,
        content: str | bytes | None = None,
        content_type: str | None = None,
    ) -> httpx.Response:
        """Make an HTTP request to Loki."""
        headers = self._headers()
        if content_type:
            headers["Content-Type"] = content_type

        resp = await self._client.request(
            method,
            path,
            params=params,
            json=json_data,
            data=data,
            content=content,
            headers=headers,
        )
        return resp

    async def close(self) -> None:
        await self._client.aclose()


# Singleton client
_client = LokiClient()


async def _get_client() -> LokiClient:
    return _client


# ---------------------------------------------------------------------------
# Response formatting
# ---------------------------------------------------------------------------


def _format_response(data: Any, summary: str | None = None) -> str:
    """Format API response data for tool output."""
    if isinstance(data, str):
        if summary:
            return f"{summary}\n\n{data}"
        return data
    if summary:
        return f"{summary}\n\n{json.dumps(data, indent=2, default=str)}"
    return json.dumps(data, indent=2, default=str)


def _unwrap_loki_response(resp: httpx.Response) -> Any:
    """Unwrap Loki's standard response envelope.

    Loki wraps most JSON responses in {"status": "success", "data": ...}.
    This extracts the data field when present.
    """
    if resp.status_code == 204:
        return {"status": "success", "message": "No content (204)"}

    content_type = resp.headers.get("content-type", "")

    # Text responses (ready, metrics, config, services)
    if "text/" in content_type or "text/html" in content_type:
        return resp.text

    # Try JSON
    try:
        body = resp.json()
    except Exception:
        return resp.text

    # Unwrap envelope
    if isinstance(body, dict) and "status" in body:
        if body["status"] != "success":
            msg = body.get("message", body.get("error", "Unknown error"))
            raise RuntimeError(f"Loki API error: {msg}")
        if "data" in body:
            data = body["data"]
            if isinstance(data, dict) and "stats" in data:
                data = {k: v for k, v in data.items() if k != "stats"}
            return data
    return body


def _handle_error(resp: httpx.Response, tool_name: str) -> str | None:
    """Check for HTTP errors and return a friendly message, or None if OK.

    Distinguishes between Loki API errors (4xx/5xx with JSON body) and
    connection/transport errors. Returns a formatted error string instead
    of raising, so the LLM gets actionable feedback instead of a traceback.
    """
    if resp.is_success:
        return None

    # Try to extract Loki's error message from JSON body
    detail = ""
    try:
        body = resp.json()
        detail = body.get("message", body.get("error", ""))
    except Exception:
        detail = resp.text[:500] if resp.text else ""

    error_data = {
        "error": True,
        "tool": tool_name,
        "status_code": resp.status_code,
        "message": detail or f"HTTP {resp.status_code} {resp.reason_phrase}",
    }

    if resp.status_code == 400:
        error_data["hint"] = "Bad request — check query syntax and parameter values."
    elif resp.status_code == 404:
        error_data["hint"] = "Not found — the resource or endpoint does not exist."
    elif resp.status_code == 422:
        error_data["hint"] = "Unprocessable — the request was well-formed but semantically invalid."
    elif resp.status_code == 429:
        error_data["hint"] = "Rate limited — wait and retry."
    elif resp.status_code >= 500:
        error_data["hint"] = "Loki server error — the instance may be overloaded or misconfigured."

    return _format_response(error_data, f"Error from {tool_name}: HTTP {resp.status_code}")


def _filter_results(
    data: Any,
    fields: str = "",
    query: dict | None = None,
    filter_path: str | None = None,
    filter_label_key: str | None = None,
) -> Any:
    """Apply client-side filtering to list results.

    Args:
        data: The unwrapped API response data.
        fields: Comma-separated field names to keep (empty = all).
        query: Dict of key-value pairs; only items where all pairs match are kept.
        filter_path: Dot path to the list within data (e.g. "result"). None = data is the list.
        filter_label_key: If items are Loki-style {stream: {labels}, values: [...]},
                          this is the key holding the label dict (e.g. "stream", "metric").
                          None = items are flat dicts.
    """
    if not fields and not query:
        return data

    # Extract the list to filter
    items = data
    if filter_path and isinstance(data, dict):
        items = data.get(filter_path, data)

    if not isinstance(items, list):
        return data

    field_set = {f.strip() for f in fields.split(",") if f.strip()} if fields else set()

    filtered = []
    for item in items:
        # Get the dict to match/filter against
        if filter_label_key and isinstance(item, dict):
            labels = item.get(filter_label_key, {})
        elif isinstance(item, dict):
            labels = item
        else:
            # Non-dict items (strings, etc.) can't be filtered
            filtered.append(item)
            continue

        # Apply query filter
        if query:
            if not all(str(labels.get(k, "")) == str(v) for k, v in query.items()):
                continue

        # Apply field projection
        if field_set and filter_label_key and isinstance(item, dict):
            projected_labels = {k: v for k, v in labels.items() if k in field_set}
            item = {**item, filter_label_key: projected_labels}
        elif field_set and isinstance(item, dict) and not filter_label_key:
            item = {k: v for k, v in item.items() if k in field_set}

        filtered.append(item)

    if filter_path and isinstance(data, dict):
        return {**data, filter_path: filtered}
    return filtered


# ---------------------------------------------------------------------------
# MCP Server
# ---------------------------------------------------------------------------

mcp = FastMCP(
    "Loki",
    instructions=(
        "This server provides 42 tools for interacting with Grafana Loki. "
        "Call loki_search_tools first to find the right tool by keyword before browsing "
        "the full tool list. Call loki_get_overview for system status. "
        "If a tool returns an unexpected error, call loki_report_issue to report it."
    ),
)


# ===========================================================================
# Direct API Tools (generated from endpoint inventory)
# ===========================================================================
# --- loki_query_instant (query) ---

@mcp.tool()
async def loki_query_instant(
    query: str,
    time: str = "",
    limit: int = 100,
    direction: str = "backward",
    fields: str = "",
    filter_query: dict | None = None,
) -> str:
    """Run an instant LogQL query at a single point in time. Returns log lines or metric vectors.

    Args:
        query: LogQL query string
        time: Evaluation timestamp (RFC3339 or Unix epoch). Defaults to now.
        limit: Maximum number of entries to return
        direction: Log ordering. Valid values: 'forward', 'backward'
        fields: Comma-separated field names to include in results (empty = all).
        filter_query: Dict of key-value pairs to filter results (e.g. {"host": "doc1"}). Only matching items returned.

    Known fields: __name__

    Note: resultType is 'streams' for log queries, 'vector' for metric queries. For stream results, filter on stream labels (host, container, etc.).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    if time:
        params["time"] = time
    if limit:
        params["limit"] = str(limit)
    if direction:
        params["direction"] = direction
    resp = await client.request(
        "GET",
        "/loki/api/v1/query",
        params=params,
    )
    if err := _handle_error(resp, "loki_query_instant"):
        return err
    result = _unwrap_loki_response(resp)
    if fields or filter_query:
        result = _filter_results(
            result,
            fields=fields,
            query=filter_query,
            filter_path="result",
            filter_label_key="metric",
        )
    if isinstance(result, dict) and "result" in result:
        entries = result["result"]
        return _format_response(result, f"Found {len(entries)} result(s)")
    return _format_response(result)

# --- loki_query_range (query) ---

@mcp.tool()
async def loki_query_range(
    query: str,
    start: str = "",
    end: str = "",
    limit: int = 100,
    direction: str = "backward",
    step: str = "",
    fields: str = "",
    filter_query: dict | None = None,
) -> str:
    """Run a LogQL query over a time range. Returns log streams or metric matrices.

    Args:
        query: LogQL query string
        start: Start timestamp (RFC3339, Unix epoch, or duration like '1h'). Defaults to 1h ago.
        end: End timestamp (RFC3339, Unix epoch, or duration like '5m'). Defaults to now.
        limit: Maximum number of entries to return
        direction: Log ordering. Valid values: 'forward', 'backward'
        step: Query resolution step width (e.g. '5m'). Only for metric queries.
        fields: Comma-separated field names to include in results (empty = all).
        filter_query: Dict of key-value pairs to filter results (e.g. {"host": "doc1"}). Only matching items returned.

    Known fields: host, container, unit, job, service_name

    Note: resultType is 'streams' for log queries, 'matrix' for metric queries. For stream results, filter on stream labels (host, container, etc.).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    if limit:
        params["limit"] = str(limit)
    if direction:
        params["direction"] = direction
    if step:
        params["step"] = step
    resp = await client.request(
        "GET",
        "/loki/api/v1/query_range",
        params=params,
    )
    if err := _handle_error(resp, "loki_query_range"):
        return err
    result = _unwrap_loki_response(resp)
    if fields or filter_query:
        result = _filter_results(
            result,
            fields=fields,
            query=filter_query,
            filter_path="result",
            filter_label_key="stream",
        )
    if isinstance(result, dict) and "result" in result:
        entries = result["result"]
        return _format_response(result, f"Found {len(entries)} result(s)")
    return _format_response(result)

# --- loki_list_labels (query) ---

@mcp.tool()
async def loki_list_labels(
    start: str = "",
    end: str = "",
) -> str:
    """List all known label names within a given time range.

    Args:
        start: Start timestamp (RFC3339, Unix epoch, or duration like '1h')
        end: End timestamp (RFC3339, Unix epoch, or duration like '5m')

    Note: data is a flat list of label name strings
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    resp = await client.request(
        "GET",
        "/loki/api/v1/labels",
        params=params,
    )
    if err := _handle_error(resp, "loki_list_labels"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_list_label_values (query) ---

@mcp.tool()
async def loki_list_label_values(
    name: str,
    start: str = "",
    end: str = "",
    query: str = "",
) -> str:
    """List all known values for a given label name.

    Args:
        name: Label name to get values for (e.g. 'host', 'container')
        start: Start timestamp
        end: End timestamp
        query: LogQL stream selector to filter label values

    Note: data is a flat list of label value strings
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    path = "/loki/api/v1/label/{name}/values"
    path = path.replace("{name}", name)
    params = {}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    if query:
        params["query"] = query
    resp = await client.request(
        "GET",
        path,
        params=params,
    )
    if err := _handle_error(resp, "loki_list_label_values"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_list_series (query) ---

@mcp.tool()
async def loki_list_series(
    match: str,
    start: str = "",
    end: str = "",
    fields: str = "",
    filter_query: dict | None = None,
) -> str:
    """List all log streams (label sets) matching a set of stream selectors.

    Args:
        match: Stream selector(s) to match. At least one match[] parameter required.
        start: Start timestamp
        end: End timestamp
        fields: Comma-separated field names to include in results (empty = all).
        filter_query: Dict of key-value pairs to filter results (e.g. {"host": "doc1"}). Only matching items returned.

    Known fields: host, container, unit, job, service_name

    Note: data is a list of label set objects. match parameter sent as match[]. Filter with fields/query on label names.
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["match[]"] = match
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    resp = await client.request(
        "GET",
        "/loki/api/v1/series",
        params=params,
    )
    if err := _handle_error(resp, "loki_list_series"):
        return err
    result = _unwrap_loki_response(resp)
    if fields or filter_query:
        result = _filter_results(
            result,
            fields=fields,
            query=filter_query,
            filter_path=None,
            filter_label_key=None,
        )
    return _format_response(result)

# --- loki_index_stats (index) ---

@mcp.tool()
async def loki_index_stats(
    query: str,
    start: str = "",
    end: str = "",
) -> str:
    """Get index statistics (streams, chunks, entries, bytes) for a LogQL query.

    Args:
        query: LogQL stream selector query
        start: Start timestamp
        end: End timestamp

    Note: Response is a flat object, not wrapped in data envelope
    """
    if not _module_enabled("index"):
        return _format_response({"error": "Module 'index' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    resp = await client.request(
        "GET",
        "/loki/api/v1/index/stats",
        params=params,
    )
    if err := _handle_error(resp, "loki_index_stats"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_index_volume (index) ---

@mcp.tool()
async def loki_index_volume(
    query: str,
    start: str = "",
    end: str = "",
    limit: int = 100,
    targetLabels: str = "",
    fields: str = "",
    filter_query: dict | None = None,
) -> str:
    """Get log volume aggregated by labels. Shows which streams generate the most logs.

    Args:
        query: LogQL stream selector query
        start: Start timestamp
        end: End timestamp
        limit: Maximum number of volumes to return
        targetLabels: Comma-separated labels to aggregate by (e.g. 'host,container')
        fields: Comma-separated field names to include in results (empty = all).
        filter_query: Dict of key-value pairs to filter results (e.g. {"host": "doc1"}). Only matching items returned.

    Known fields: host, container, unit, job, service_name

    Note: Requires volume_enabled in Loki config. Filter on label names used in aggregation. For a simpler interface, use loki_volume_by_label which accepts a single 'label' parameter instead of requiring a LogQL query and targetLabels.
    """
    if not _module_enabled("index"):
        return _format_response({"error": "Module 'index' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    if limit:
        params["limit"] = str(limit)
    if targetLabels:
        params["targetLabels"] = targetLabels
    resp = await client.request(
        "GET",
        "/loki/api/v1/index/volume",
        params=params,
    )
    if err := _handle_error(resp, "loki_index_volume"):
        return err
    result = _unwrap_loki_response(resp)
    if fields or filter_query:
        result = _filter_results(
            result,
            fields=fields,
            query=filter_query,
            filter_path="result",
            filter_label_key="metric",
        )
    if isinstance(result, dict) and "result" in result:
        entries = result["result"]
        return _format_response(result, f"Found {len(entries)} result(s)")
    return _format_response(result)

# --- loki_index_volume_range (index) ---

@mcp.tool()
async def loki_index_volume_range(
    query: str,
    start: str = "",
    end: str = "",
    limit: int = 100,
    step: str = "",
    targetLabels: str = "",
    fields: str = "",
    filter_query: dict | None = None,
) -> str:
    """Get log volume over time, aggregated by labels. Shows volume trends.

    Args:
        query: LogQL stream selector query
        start: Start timestamp
        end: End timestamp
        limit: Maximum number of volumes to return
        step: Query resolution step width (e.g. '5m')
        targetLabels: Comma-separated labels to aggregate by
        fields: Comma-separated field names to include in results (empty = all).
        filter_query: Dict of key-value pairs to filter results (e.g. {"host": "doc1"}). Only matching items returned.

    Known fields: host, container, unit, job, service_name

    Note: Requires volume_enabled in Loki config. Filter on label names used in aggregation.
    """
    if not _module_enabled("index"):
        return _format_response({"error": "Module 'index' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    if limit:
        params["limit"] = str(limit)
    if step:
        params["step"] = step
    if targetLabels:
        params["targetLabels"] = targetLabels
    resp = await client.request(
        "GET",
        "/loki/api/v1/index/volume_range",
        params=params,
    )
    if err := _handle_error(resp, "loki_index_volume_range"):
        return err
    result = _unwrap_loki_response(resp)
    if fields or filter_query:
        result = _filter_results(
            result,
            fields=fields,
            query=filter_query,
            filter_path="result",
            filter_label_key="metric",
        )
    if isinstance(result, dict) and "result" in result:
        entries = result["result"]
        return _format_response(result, f"Found {len(entries)} result(s)")
    return _format_response(result)

# --- loki_detect_patterns (patterns) ---

@mcp.tool()
async def loki_detect_patterns(
    query: str,
    start: str = "",
    end: str = "",
) -> str:
    """Detect common log line patterns within a stream. Clusters similar log lines together.

    Args:
        query: LogQL stream selector query
        start: Start timestamp
        end: End timestamp

    Note: Requires pattern_ingester enabled in Loki config
    """
    if not _module_enabled("patterns"):
        return _format_response({"error": "Module 'patterns' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)
    resp = await client.request(
        "GET",
        "/loki/api/v1/patterns",
        params=params,
    )
    if err := _handle_error(resp, "loki_detect_patterns"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_push (ingest) ---

@mcp.tool()
async def loki_push(
    streams: list,
    confirm: bool = False,
) -> str:
    """Push log entries to Loki. Entries must include streams with labels and log line values.

    Args:
        streams: List of stream objects. Each has 'stream' (label dict) and 'values' (list of [timestamp_ns, line] pairs).
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Wait a moment for ingestion, then verify with loki_query_range.

    Note: Returns 204 No Content on success. Timestamps must be nanosecond Unix epoch strings.
    """
    if not confirm:
        preview = {"action": "loki_push"}
        preview["streams_count"] = len(streams)
        return _format_response(
            preview,
            "DRY RUN: Set confirm=True to execute.",
        )

    if not _module_enabled("ingest"):
        return _format_response({"error": "Module 'ingest' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    payload = {"streams": streams}
    resp = await client.request("POST", "/loki/api/v1/push", json_data=payload)
    if err := _handle_error(resp, "loki_push"):
        return err
    return _format_response({"status": "success", "message": f"Pushed {len(streams)} stream(s)"})

# --- loki_list_rules (rules) ---

@mcp.tool()
async def loki_list_rules(
) -> str:
    """List all alerting and recording rules across all namespaces.

    Note: Returns rule groups organized by namespace
    """
    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    resp = await client.request(
        "GET",
        "/loki/api/v1/rules",
        params=params,
    )
    if err := _handle_error(resp, "loki_list_rules"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_get_rules_namespace (rules) ---

@mcp.tool()
async def loki_get_rules_namespace(
    namespace: str,
) -> str:
    """List all rule groups within a specific namespace.

    Args:
        namespace: Rule namespace name
    """
    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    path = "/loki/api/v1/rules/{namespace}"
    path = path.replace("{namespace}", namespace)
    params = {}
    resp = await client.request(
        "GET",
        path,
        params=params,
    )
    if err := _handle_error(resp, "loki_get_rules_namespace"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_get_rule_group (rules) ---

@mcp.tool()
async def loki_get_rule_group(
    namespace: str,
    group: str,
) -> str:
    """Get a specific rule group by namespace and group name.

    Args:
        namespace: Rule namespace name
        group: Rule group name
    """
    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    path = "/loki/api/v1/rules/{namespace}/{group}"
    path = path.replace("{namespace}", namespace)
    path = path.replace("{group}", group)
    params = {}
    resp = await client.request(
        "GET",
        path,
        params=params,
    )
    if err := _handle_error(resp, "loki_get_rule_group"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_create_rule_group (rules) ---

@mcp.tool()
async def loki_create_rule_group(
    namespace: str,
    rules_yaml: str,
    confirm: bool = False,
) -> str:
    """Create or update a rule group within a namespace. Replaces the entire group if it exists.

    Args:
        namespace: Rule namespace name
        rules_yaml: YAML-encoded rule group definition (name, interval, rules list)
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Verify with loki_get_rule_group or loki_list_rules.

    Note: Content-Type must be application/yaml. Returns 202 Accepted.
    """
    if not confirm:
        preview = {"action": "loki_create_rule_group"}
        preview["namespace"] = namespace
        preview["rules_yaml"] = rules_yaml
        return _format_response(
            preview,
            "DRY RUN: Set confirm=True to execute.",
        )

    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    path = "/loki/api/v1/rules/{namespace}"
    path = path.replace("{namespace}", namespace)
    resp = await client.request(
        "POST",
        path,
        content=rules_yaml.encode(),
        content_type="application/yaml",
    )
    if err := _handle_error(resp, "loki_create_rule_group"):
        return err
    return _format_response({"status": "success", "message": "Rule group created/updated"})

# --- loki_delete_rule_group (rules) ---

@mcp.tool()
async def loki_delete_rule_group(
    namespace: str,
    group: str,
    confirm: bool = False,
) -> str:
    """Delete a specific rule group from a namespace.

    Args:
        namespace: Rule namespace name
        group: Rule group name to delete
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Verify deletion with loki_list_rules.

    Note: Returns 202 Accepted
    """
    if not confirm:
        preview = {"action": "loki_delete_rule_group"}
        preview["namespace"] = namespace
        preview["group"] = group
        return _format_response(
            preview,
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
        )

    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    path = "/loki/api/v1/rules/{namespace}/{group}"
    path = path.replace("{namespace}", namespace)
    path = path.replace("{group}", group)
    resp = await client.request(
        "DELETE",
        path,
    )
    if err := _handle_error(resp, "loki_delete_rule_group"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_delete_rule_group completed")

# --- loki_delete_rules_namespace (rules) ---

@mcp.tool()
async def loki_delete_rules_namespace(
    namespace: str,
    confirm: bool = False,
) -> str:
    """Delete all rule groups in a namespace.

    Args:
        namespace: Rule namespace name to delete entirely
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Verify deletion with loki_list_rules.

    Note: Returns 202 Accepted. Deletes ALL rule groups in the namespace.
    """
    if not confirm:
        preview = {"action": "loki_delete_rules_namespace"}
        preview["namespace"] = namespace
        return _format_response(
            preview,
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
        )

    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    path = "/loki/api/v1/rules/{namespace}"
    path = path.replace("{namespace}", namespace)
    resp = await client.request(
        "DELETE",
        path,
    )
    if err := _handle_error(resp, "loki_delete_rules_namespace"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_delete_rules_namespace completed")

# --- loki_list_prometheus_rules (rules) ---

@mcp.tool()
async def loki_list_prometheus_rules(
    type: str = "",
) -> str:
    """List rules in Prometheus-compatible format. Includes firing status and health.

    Args:
        type: Filter by rule type. Valid values: 'alert', 'record'

    Note: Same data as list_rules but in Prometheus /api/v1/rules format with evaluation status
    """
    if not _module_enabled("rules"):
        return _format_response({"error": "Module 'rules' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    if type:
        params["type"] = type
    resp = await client.request(
        "GET",
        "/prometheus/api/v1/rules",
        params=params,
    )
    if err := _handle_error(resp, "loki_list_prometheus_rules"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_create_delete_request (delete) ---

@mcp.tool()
async def loki_create_delete_request(
    query: str,
    start: str,
    end: str,
    confirm: bool = False,
) -> str:
    """Create a request to delete log entries matching a query within a time range.

    Args:
        query: LogQL stream selector for logs to delete
        start: Start of deletion time range (RFC3339)
        end: End of deletion time range (RFC3339)
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Deletion is async. Check status with loki_list_delete_requests.

    Note: Returns 204 No Content. Requires compactor with deletion enabled. Deletion is async.
    """
    if not confirm:
        preview = {"action": "loki_create_delete_request"}
        preview["query"] = query
        preview["start"] = start
        preview["end"] = end
        return _format_response(
            preview,
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
        )

    if not _module_enabled("delete"):
        return _format_response({"error": "Module 'delete' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    params = {}
    params["query"] = query
    params["start"] = start
    params["end"] = end
    resp = await client.request(
        "POST",
        "/loki/api/v1/delete",
        params=params,
    )
    if err := _handle_error(resp, "loki_create_delete_request"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_create_delete_request completed")

# --- loki_list_delete_requests (delete) ---

@mcp.tool()
async def loki_list_delete_requests(
    fields: str = "",
    filter_query: dict | None = None,
) -> str:
    """List all pending and processed delete requests.

    Known fields: request_id, start_time, end_time, query, status, created_at

    Note: Filter with fields/query on response object fields.
    """
    if not _module_enabled("delete"):
        return _format_response({"error": "Module 'delete' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    resp = await client.request(
        "GET",
        "/loki/api/v1/delete",
        params=params,
    )
    if err := _handle_error(resp, "loki_list_delete_requests"):
        return err
    result = _unwrap_loki_response(resp)
    if fields or filter_query:
        result = _filter_results(
            result,
            fields=fields,
            query=filter_query,
            filter_path=None,
            filter_label_key=None,
        )
    return _format_response(result)

# --- loki_cancel_delete_request (delete) ---

@mcp.tool()
async def loki_cancel_delete_request(
    request_id: str,
    confirm: bool = False,
) -> str:
    """Cancel a pending delete request.

    Args:
        request_id: ID of the delete request to cancel
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Verify cancellation with loki_list_delete_requests.

    Note: Returns 204 No Content. Only pending requests can be cancelled.
    """
    if not confirm:
        preview = {"action": "loki_cancel_delete_request"}
        preview["request_id"] = request_id
        return _format_response(
            preview,
            "DRY RUN: Set confirm=True to execute.",
        )

    if not _module_enabled("delete"):
        return _format_response({"error": "Module 'delete' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    params = {}
    params["request_id"] = request_id
    resp = await client.request(
        "DELETE",
        "/loki/api/v1/delete",
        params=params,
    )
    if err := _handle_error(resp, "loki_cancel_delete_request"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_cancel_delete_request completed")

# --- loki_ready (status) ---

@mcp.tool()
async def loki_ready(
) -> str:
    """Check if Loki is ready to accept traffic. Returns 'ready' when all components are up.

    Note: Returns 200 with body 'ready' or 503 if not ready. Text response, not JSON.
    """
    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    resp = await client.request("GET", "/ready")
    if err := _handle_error(resp, "loki_ready"):
        return err
    return _format_response(resp.text, "loki_ready response")

# --- loki_metrics (status) ---

@mcp.tool()
async def loki_metrics(
) -> str:
    """Get Prometheus metrics from this Loki instance. Returns metrics in Prometheus exposition format.

    Note: Returns text/plain in Prometheus exposition format, not JSON.
    """
    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    resp = await client.request("GET", "/metrics")
    if err := _handle_error(resp, "loki_metrics"):
        return err
    return _format_response(resp.text, "loki_metrics response")

# --- loki_config (status) ---

@mcp.tool()
async def loki_config(
) -> str:
    """Get the current Loki configuration. Shows all runtime settings.

    Note: Returns YAML-formatted configuration text.
    """
    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    resp = await client.request("GET", "/config")
    if err := _handle_error(resp, "loki_config"):
        return err
    return _format_response(resp.text, "loki_config response")

# --- loki_services (status) ---

@mcp.tool()
async def loki_services(
) -> str:
    """List all internal Loki services and their current states.

    Note: Returns an HTML page listing services and states. Parse as text.
    """
    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    resp = await client.request("GET", "/services")
    if err := _handle_error(resp, "loki_services"):
        return err
    return _format_response(resp.text, "loki_services response")

# --- loki_buildinfo (status) ---

@mcp.tool()
async def loki_buildinfo(
) -> str:
    """Get Loki build information including version, revision, branch, and Go version.
    """
    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    resp = await client.request(
        "GET",
        "/loki/api/v1/status/buildinfo",
        params=params,
    )
    if err := _handle_error(resp, "loki_buildinfo"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_get_log_level (status) ---

@mcp.tool()
async def loki_get_log_level(
) -> str:
    """Get the current log level of the Loki instance.
    """
    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    resp = await client.request(
        "GET",
        "/log_level",
        params=params,
    )
    if err := _handle_error(resp, "loki_get_log_level"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_set_log_level (status) ---

@mcp.tool()
async def loki_set_log_level(
    log_level: str,
    confirm: bool = False,
) -> str:
    """Change the runtime log level of the Loki instance.

    Args:
        log_level: New log level. Valid values: 'debug', 'info', 'warn', 'error'
        confirm: Must be True to execute. Returns preview if False.

    Follow-up: Verify with loki_get_log_level.

    Note: Sent as form-encoded body: log_level=<value>
    """
    if not confirm:
        preview = {"action": "loki_set_log_level"}
        preview["log_level"] = log_level
        return _format_response(
            preview,
            "DRY RUN: Set confirm=True to execute.",
        )

    if not _module_enabled("status"):
        return _format_response({"error": "Module 'status' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    resp = await client.request(
        "POST",
        "/log_level",
        data={"log_level": log_level},
        content_type="application/x-www-form-urlencoded",
    )
    if err := _handle_error(resp, "loki_set_log_level"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "Log level updated")

# --- loki_flush (admin) ---

@mcp.tool()
async def loki_flush(
    confirm: bool = False,
) -> str:
    """Flush all in-memory chunks to backing store. Forces immediate persistence.

    Follow-up: Monitor with loki_metrics after flushing.

    Note: Returns 204 No Content. Can impact performance during flush.
    """
    if not confirm:
        preview = {"action": "loki_flush"}
        return _format_response(
            preview,
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
        )

    if not _module_enabled("admin"):
        return _format_response({"error": "Module 'admin' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    resp = await client.request(
        "POST",
        "/flush",
    )
    if err := _handle_error(resp, "loki_flush"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_flush completed")

# --- loki_prepare_shutdown_status (admin) ---

@mcp.tool()
async def loki_prepare_shutdown_status(
) -> str:
    """Check the prepare-shutdown status of the ingester.

    Note: Returns text with current preparation status
    """
    if not _module_enabled("admin"):
        return _format_response({"error": "Module 'admin' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    resp = await client.request(
        "GET",
        "/ingester/prepare_shutdown",
        params=params,
    )
    if err := _handle_error(resp, "loki_prepare_shutdown_status"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_prepare_shutdown (admin) ---

@mcp.tool()
async def loki_prepare_shutdown(
    confirm: bool = False,
) -> str:
    """Signal the ingester to prepare for shutdown. Flushes data and stops accepting writes.

    Follow-up: Check status with loki_prepare_shutdown_status. Cancel with loki_cancel_prepare_shutdown if needed.

    Note: Returns 204 No Content. Initiates graceful shutdown preparation.
    """
    if not confirm:
        preview = {"action": "loki_prepare_shutdown"}
        return _format_response(
            preview,
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
        )

    if not _module_enabled("admin"):
        return _format_response({"error": "Module 'admin' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    resp = await client.request(
        "POST",
        "/ingester/prepare_shutdown",
    )
    if err := _handle_error(resp, "loki_prepare_shutdown"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_prepare_shutdown completed")

# --- loki_cancel_prepare_shutdown (admin) ---

@mcp.tool()
async def loki_cancel_prepare_shutdown(
    confirm: bool = False,
) -> str:
    """Cancel a previously initiated prepare-shutdown. Resumes normal operation.

    Note: Returns 204 No Content
    """
    if not confirm:
        preview = {"action": "loki_cancel_prepare_shutdown"}
        return _format_response(
            preview,
            "DRY RUN: Set confirm=True to execute.",
        )

    if not _module_enabled("admin"):
        return _format_response({"error": "Module 'admin' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    resp = await client.request(
        "DELETE",
        "/ingester/prepare_shutdown",
    )
    if err := _handle_error(resp, "loki_cancel_prepare_shutdown"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_cancel_prepare_shutdown completed")

# --- loki_shutdown_status (admin) ---

@mcp.tool()
async def loki_shutdown_status(
) -> str:
    """Check the shutdown status of the ingester.

    Note: Returns text with current shutdown status
    """
    if not _module_enabled("admin"):
        return _format_response({"error": "Module 'admin' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    resp = await client.request(
        "GET",
        "/ingester/shutdown",
        params=params,
    )
    if err := _handle_error(resp, "loki_shutdown_status"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)

# --- loki_shutdown (admin) ---

@mcp.tool()
async def loki_shutdown(
    confirm: bool = False,
) -> str:
    """Trigger immediate shutdown of the ingester. DANGEROUS: causes data loss if chunks not flushed.

    Follow-up: Call loki_prepare_shutdown FIRST to flush data and avoid data loss.

    Note: Returns 204 No Content. WARNING: May cause data loss. Use prepare_shutdown first.
    """
    if not confirm:
        preview = {"action": "loki_shutdown"}
        return _format_response(
            preview,
            "⚠️ DANGEROUS OPERATION — Set confirm=True to execute.",
        )

    if not _module_enabled("admin"):
        return _format_response({"error": "Module 'admin' is not enabled. Set LOKI_MODULES to include it."})

    if LOKI_READ_ONLY:
        return _format_response({"error": "Server is in read-only mode. Set LOKI_READ_ONLY=false to allow mutations."})

    client = await _get_client()
    resp = await client.request(
        "POST",
        "/ingester/shutdown",
    )
    if err := _handle_error(resp, "loki_shutdown"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, "loki_shutdown completed")

# --- loki_format_query (format) ---

@mcp.tool()
async def loki_format_query(
    query: str,
) -> str:
    """Format and validate a LogQL query. Returns the prettified form or an error.

    Args:
        query: LogQL query string to format/validate

    Note: Useful for validating LogQL syntax. Also accepts POST with form-encoded body.
    """
    if not _module_enabled("format"):
        return _format_response({"error": "Module 'format' is not enabled. Set LOKI_MODULES to include it."})

    client = await _get_client()
    params = {}
    params["query"] = query
    resp = await client.request(
        "GET",
        "/loki/api/v1/format_query",
        params=params,
    )
    if err := _handle_error(resp, "loki_format_query"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result)


# ===========================================================================
# High-Level AI-Friendly Tools
# ===========================================================================


@mcp.tool()
async def loki_search_logs(
    host: str = "",
    container: str = "",
    unit: str = "",
    pattern: str = "",
    exclude: str = "",
    severity: str = "",
    start: str = "1h",
    end: str = "",
    limit: int = 100,
    direction: str = "backward",
) -> str:
    """Search logs by host, container, unit, pattern, and severity — no LogQL needed.

    Builds a LogQL query internally from structured parameters.

    Args:
        host: Filter by host label (exact match).
        container: Filter by container label (exact match).
        unit: Filter by systemd unit label (exact match).
        pattern: Regex pattern to include log lines (e.g. 'error|timeout'). Uses |~ (include match).
        exclude: Regex pattern to exclude log lines (e.g. 'healthcheck|ping'). Uses !~ (exclude match).
        severity: Minimum severity: 'debug', 'info', 'warn', 'error', 'critical', 'fatal'.
        start: Start time — duration like '1h', '30m' or RFC3339. Default: 1h ago.
        end: End time — duration or RFC3339. Default: now.
        limit: Maximum log entries to return (default: 100).
        direction: 'backward' (newest first) or 'forward' (oldest first).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled."})

    # Build stream selector
    labels = {}
    if host:
        labels["host"] = host
    if container:
        labels["container"] = container
    if unit:
        labels["unit"] = unit

    if not labels:
        selector = '{}'
    else:
        parts = [f'{k}="{v}"' for k, v in labels.items()]
        selector = "{" + ", ".join(parts) + "}"

    # Build pipeline
    pipeline = ""
    if pattern:
        pipeline += f' |~ "{pattern}"'
    if exclude:
        pipeline += f' !~ "{exclude}"'

    severity_levels = {"debug": 0, "info": 1, "warn": 2, "warning": 2, "error": 3, "critical": 4, "fatal": 5}
    if severity and severity.lower() in severity_levels:
        level_num = severity_levels[severity.lower()]
        level_patterns = [k for k, v in severity_levels.items() if v >= level_num and k != "warning"]
        if level_patterns:
            sev_regex = "|".join(level_patterns)
            pipeline += f' |~ "(?i)({sev_regex})"'

    query = selector + pipeline

    # Execute query
    client = await _get_client()
    params: dict[str, str] = {"query": query, "limit": str(limit), "direction": direction}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/query_range", params=params)
    if err := _handle_error(resp, "loki_search_logs"):
        return err
    result = _unwrap_loki_response(resp)
    _format_log_values(result)

    # Format output
    summary = f"Query: {query}"
    if isinstance(result, dict) and "result" in result:
        streams = result["result"]
        total_lines = sum(len(s.get("values", [])) for s in streams)
        summary += f"\nStreams: {len(streams)}, Log lines: {total_lines}"
    return _format_response(result, summary)


@mcp.tool()
async def loki_error_summary(
    host: str = "",
    exclude: str = "",
    start: str = "1h",
    end: str = "",
    limit: int = 50,
) -> str:
    """Aggregate errors across containers for a host.

    Searches for error/fail/exception/panic/fatal patterns and groups by container.

    Args:
        host: Filter by host label. Leave empty for all hosts.
        exclude: Regex pattern to exclude log lines (e.g. 'healthcheck|ping'). Uses !~ (exclude match).
        start: Start time (default: 1h ago).
        end: End time (default: now).
        limit: Maximum entries per stream (default: 50).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled."})

    selector = "{" + f'host="{host}"' + "}" if host else "{}"
    query = selector + ' |~ "(?i)(error|fail|exception|panic|fatal)"'
    if exclude:
        query += f' !~ "{exclude}"'

    client = await _get_client()
    params: dict[str, str] = {"query": query, "limit": str(limit), "direction": "backward"}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/query_range", params=params)
    if err := _handle_error(resp, "loki_error_summary"):
        return err
    result = _unwrap_loki_response(resp)

    # Build summary
    summary_data: dict[str, dict] = {}
    if isinstance(result, dict) and "result" in result:
        for stream in result["result"]:
            labels = stream.get("stream", {})
            key = labels.get("container", labels.get("unit", labels.get("host", "unknown")))
            values = stream.get("values", [])
            if key not in summary_data:
                summary_data[key] = {"count": 0, "latest": "", "first_seen": ""}
            summary_data[key]["count"] += len(values)
            if values:
                summary_data[key]["latest"] = values[0][1][:200]
                summary_data[key]["first_seen"] = _format_ns_timestamp(values[-1][0])

    return _format_response(
        {"query": query, "error_summary": summary_data},
        f"Error summary: {sum(s['count'] for s in summary_data.values())} errors across {len(summary_data)} source(s)",
    )


@mcp.tool()
async def loki_volume_by_label(
    label: str = "host",
    start: str = "1h",
    end: str = "",
    limit: int = 20,
) -> str:
    """Find the noisiest hosts/containers by log volume.

    Args:
        label: Label to aggregate by (default: 'host'). Common: 'host', 'container', 'unit'.
        start: Start time (default: 1h ago).
        end: End time (default: now).
        limit: Maximum results (default: 20).

    Note: This is a simplified wrapper around loki_index_volume. For advanced usage
    (custom LogQL selectors, multiple targetLabels, field filtering), use loki_index_volume directly.
    """
    if not _module_enabled("index"):
        return _format_response({"error": "Module 'index' is not enabled."})

    client = await _get_client()
    params: dict[str, str] = {"query": "{}", "limit": str(limit), "targetLabels": label}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/index/volume", params=params)
    if err := _handle_error(resp, "loki_volume_by_label"):
        return err
    result = _unwrap_loki_response(resp)
    return _format_response(result, f"Volume by {label}")


@mcp.tool()
async def loki_compare_hosts(
    hosts: str,
    pattern: str = "",
    exclude: str = "",
    start: str = "1h",
    end: str = "",
    limit: int = 50,
) -> str:
    """Compare logs across multiple hosts side-by-side.

    Args:
        hosts: Comma-separated host names (e.g. 'doc1,igpu,wsl').
        pattern: Regex pattern to include log lines. Uses |~ (include match).
        exclude: Regex pattern to exclude log lines (e.g. 'healthcheck|ping'). Uses !~ (exclude match).
        start: Start time (default: 1h ago).
        end: End time (default: now).
        limit: Maximum entries per host (default: 50).
    """
    if not _module_enabled("query"):
        return _format_response({"error": "Module 'query' is not enabled."})

    host_list = [h.strip() for h in hosts.split(",") if h.strip()]
    if not host_list:
        return _format_response({"error": "At least one host is required."})

    host_regex = "|".join(host_list)
    selector = '{host=~"' + host_regex + '"}'
    query = selector
    if pattern:
        query += f' |~ "{pattern}"'
    if exclude:
        query += f' !~ "{exclude}"'

    client = await _get_client()
    params: dict[str, str] = {"query": query, "limit": str(limit), "direction": "backward"}
    if start:
        params["start"] = _parse_timestamp(start)
    if end:
        params["end"] = _parse_timestamp(end)

    resp = await client.request("GET", "/loki/api/v1/query_range", params=params)
    if err := _handle_error(resp, "loki_compare_hosts"):
        return err
    result = _unwrap_loki_response(resp)
    _format_log_values(result)

    # Group by host
    by_host: dict[str, int] = {}
    if isinstance(result, dict) and "result" in result:
        for stream in result["result"]:
            h = stream.get("stream", {}).get("host", "unknown")
            by_host[h] = by_host.get(h, 0) + len(stream.get("values", []))

    return _format_response(
        {"query": query, "results": result, "lines_per_host": by_host},
        f"Comparing {len(host_list)} host(s): {', '.join(host_list)}",
    )


@mcp.tool()
async def loki_get_overview() -> str:
    """System summary: build info, readiness, services, label inventory.

    Calls multiple status endpoints to build a comprehensive overview.
    No parameters needed.
    """
    client = await _get_client()
    overview: dict[str, Any] = {}

    # Readiness
    try:
        resp = await client.request("GET", "/ready")
        overview["ready"] = resp.status_code == 200
        overview["ready_text"] = resp.text.strip()
    except Exception as e:
        overview["ready"] = False
        overview["ready_error"] = str(e)

    # Build info
    try:
        resp = await client.request("GET", "/loki/api/v1/status/buildinfo")
        if resp.status_code == 200:
            overview["buildinfo"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    # Labels
    try:
        resp = await client.request("GET", "/loki/api/v1/labels")
        if resp.status_code == 200:
            overview["labels"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    # Host values
    try:
        resp = await client.request("GET", "/loki/api/v1/label/host/values")
        if resp.status_code == 200:
            overview["hosts"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    # Container values
    try:
        resp = await client.request("GET", "/loki/api/v1/label/container/values")
        if resp.status_code == 200:
            overview["containers"] = _unwrap_loki_response(resp)
    except Exception:
        pass

    return _format_response(overview, "Loki System Overview")


# --- Tool discovery ---

_ALL_TOOLS: dict[str, str] = {
    "loki_query_instant": "Run an instant LogQL query at a single point in time. Returns log lines or metric vectors.",
    "loki_query_range": "Run a LogQL query over a time range. Returns log streams or metric matrices.",
    "loki_list_labels": "List all known label names within a given time range.",
    "loki_list_label_values": "List all known values for a given label name.",
    "loki_list_series": "List all log streams (label sets) matching a set of stream selectors.",
    "loki_index_stats": "Get index statistics (streams, chunks, entries, bytes) for a LogQL query.",
    "loki_index_volume": "Get log volume aggregated by labels. Shows which streams generate the most logs.",
    "loki_index_volume_range": "Get log volume over time, aggregated by labels. Shows volume trends.",
    "loki_detect_patterns": "Detect common log line patterns within a stream. Clusters similar log lines together.",
    "loki_push": "Push log entries to Loki. Entries must include streams with labels and log line values.",
    "loki_list_rules": "List all alerting and recording rules across all namespaces.",
    "loki_get_rules_namespace": "List all rule groups within a specific namespace.",
    "loki_get_rule_group": "Get a specific rule group by namespace and group name.",
    "loki_create_rule_group": "Create or update a rule group within a namespace. Replaces the entire group if it exists.",
    "loki_delete_rule_group": "Delete a specific rule group from a namespace.",
    "loki_delete_rules_namespace": "Delete all rule groups in a namespace.",
    "loki_list_prometheus_rules": "List rules in Prometheus-compatible format. Includes firing status and health.",
    "loki_create_delete_request": "Create a request to delete log entries matching a query within a time range.",
    "loki_list_delete_requests": "List all pending and processed delete requests.",
    "loki_cancel_delete_request": "Cancel a pending delete request.",
    "loki_ready": "Check if Loki is ready to accept traffic. Returns 'ready' when all components are up.",
    "loki_metrics": "Get Prometheus metrics from this Loki instance. Returns metrics in Prometheus exposition format.",
    "loki_config": "Get the current Loki configuration. Shows all runtime settings.",
    "loki_services": "List all internal Loki services and their current states.",
    "loki_buildinfo": "Get Loki build information including version, revision, branch, and Go version.",
    "loki_get_log_level": "Get the current log level of the Loki instance.",
    "loki_set_log_level": "Change the runtime log level of the Loki instance.",
    "loki_flush": "Flush all in-memory chunks to backing store. Forces immediate persistence.",
    "loki_prepare_shutdown_status": "Check the prepare-shutdown status of the ingester.",
    "loki_prepare_shutdown": "Signal the ingester to prepare for shutdown. Flushes data and stops accepting writes.",
    "loki_cancel_prepare_shutdown": "Cancel a previously initiated prepare-shutdown. Resumes normal operation.",
    "loki_shutdown_status": "Check the shutdown status of the ingester.",
    "loki_shutdown": "Trigger immediate shutdown of the ingester. DANGEROUS: causes data loss if chunks not flushed.",
    "loki_format_query": "Format and validate a LogQL query. Returns the prettified form or an error.",
    "loki_search_logs": "Search logs by host/container/unit/pattern/severity without LogQL. Supports include and exclude patterns.",
    "loki_error_summary": "Aggregate errors across containers for a host",
    "loki_volume_by_label": "Find noisiest hosts/containers by log volume",
    "loki_compare_hosts": "Compare logs across multiple hosts side-by-side. Supports include and exclude patterns.",
    "loki_get_overview": "System summary: build info, readiness, labels, hosts",
    "loki_search_tools": "Search for tools by keyword",
    "loki_report_issue": "Generate a structured bug report",
    "loki_validate_query": "Validate and format a LogQL query",
}


@mcp.tool()
async def loki_search_tools(keyword: str) -> str:
    """Search for Loki tools by keyword.

    Args:
        keyword: Search term to match against tool names and descriptions.
    """
    keyword_lower = keyword.lower()
    matches = []
    for name, desc in _ALL_TOOLS.items():
        if keyword_lower in name.lower() or keyword_lower in desc.lower():
            matches.append({"tool": name, "description": desc})

    if not matches:
        return _format_response(
            {"keyword": keyword, "matches": []},
            f"No tools matching '{keyword}'. Try a broader search.",
        )
    return _format_response(
        {"keyword": keyword, "matches": matches},
        f"Found {len(matches)} tool(s) matching '{keyword}'",
    )


@mcp.tool()
async def loki_report_issue(
    tool_name: str,
    error: str,
    parameters: str = "",
    description: str = "",
) -> str:
    """Generate a structured bug report for a Loki MCP tool issue.

    Args:
        tool_name: Name of the tool that failed.
        error: Error message or unexpected behavior.
        parameters: Parameters used when the error occurred.
        description: Additional context about what you were trying to do.
    """
    report = {
        "tool": tool_name,
        "error": error,
        "parameters": parameters,
        "description": description,
        "loki_url": LOKI_URL,
        "gh_command": (
            f'gh issue create --repo abl030/loki-mcp '
            f'--title "Bug: {tool_name} — {error[:50]}" '
            f'--body "## Tool\\n`{tool_name}`\\n\\n'
            f'## Error\\n```\\n{error}\\n```\\n\\n'
            f'## Parameters\\n```\\n{parameters}\\n```\\n\\n'
            f'## Description\\n{description}"'
        ),
    }
    return _format_response(report, "Bug report generated. Run the gh command to file it.")


@mcp.tool()
async def loki_validate_query(query: str) -> str:
    """Validate and format a LogQL query. Returns the prettified form or an error.

    Args:
        query: LogQL query string to validate.
    """
    if not _module_enabled("format"):
        return _format_response({"error": "Module 'format' is not enabled."})

    client = await _get_client()
    resp = await client.request("GET", "/loki/api/v1/format_query", params={"query": query})

    if resp.status_code == 200:
        result = _unwrap_loki_response(resp)
        return _format_response(
            {"valid": True, "original": query, "formatted": result},
            "Query is valid",
        )
    else:
        try:
            body = resp.json()
            error_msg = body.get("message", body.get("error", resp.text))
        except Exception:
            error_msg = resp.text
        return _format_response(
            {"valid": False, "original": query, "error": error_msg},
            "Query is INVALID",
        )


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    mcp.run()
